#!/usr/bin/env python3
import os
import sys
import argparse
import json
import subprocess
import re

try:
    import colorama
    colorama.just_fix_windows_console()
except Exception:
    pass

GREEN = "\033[92m"
RED   = "\033[91m"
RESET = "\033[0m"
CHECK = "✓"
CROSS = "✗"

# Semantic Testcases Tester
# Usage: ./semantic_testcases_tester (-t <folder_path>) (-m <myfolder_path>) (-n <max_test_num>) (-p <prefix>) (-o (<outputfile>))
# Example: ./semantic_testcases_tester -t ./testcases/semantic_check (-n 10) (-p array) (-o semantic-1-result.txt)
# -t 测试 testcases 下的 folder_path 文件夹
# -m 测试 test 下的 myfolder_path 文件夹
# -n 测试前 max_test_num 个测试用例，如果不指定 max_test_num 则测试所有测试用例 
# -p : 如果指定了 prefix，则只测试以 prefix 开头的测试用例
# -o : 如果指定了 outputfile，则将输出写入该文件，否则输出到终端
# 如果 -o 没有参数，那么就是输出到 <t>-result
# 找到 folder_path 下的每个文件夹，每个文件夹里面应该有一个 .rx 文件和一个 .json 文件 
# 对每个文件夹，调用 checker_path 来检查 .rx 文件，捕获 stdout/stderr
# 如果输出和 .json 文件内容中 compileexitcode 这一项相同，则测试通过，否则测试不通过 
# 如果不通过，并且是输出 -1，则打印 stderr 的内容 
# 若 checker 本身非零退出（RE），打印“(RE)”并输出 stderr
# 最后打印测试通过的数量和测试不通过的数量

checker_path = "../test/build/semantic_check/test_semantic_check"

def parse_int_from_text(s: str):
    """从文本中提取第一个整数（含可选的正负号），失败返回 None。"""
    if not s:
        return None
    m = re.search(r"[+-]?\d+", s.strip())
    if not m:
        return None
    try:
        return int(m.group(0))
    except ValueError:
        return None

def load_expected_exitcode(json_path: str):
    with open(json_path, "r", encoding="utf-8") as f:
        try:
            obj = json.load(f)
        except json.JSONDecodeError as e:
            raise ValueError(f"Invalid JSON ({json_path}): {e}")
    if "compileexitcode" not in obj:
        raise KeyError(f"`compileexitcode` missing in {json_path}")
    exp = obj["compileexitcode"]
    # 允许 int 或字符串数字
    try:
        return int(exp)
    except (TypeError, ValueError):
        raise ValueError(f"`compileexitcode` should be int-like, got: {exp!r} in {json_path}")

def main():
    parser = argparse.ArgumentParser(description="Semantic Testcases Tester")
    parser.add_argument("-t", "--testcases_folder", type=str,
                        help="Path to the folder containing test case folders")
    parser.add_argument("-m", "--myfolder_path", type=str,
                        help="Path to the folder containing my test case folders")
    parser.add_argument("-n", "--max_test_num", type=int, default=-1,
                        help="Maximum number of test cases to run (default: all)")
    parser.add_argument("-p", "--pre", type=str, default=None,
                        help="Only test cases whose folder name starts with this prefix; stop when a non-matching name is encountered")
    parser.add_argument(
        "-o", "--outputfile",
        nargs="?",              # ← 允许不带参数
        const="",               # ← 如果没写参数，值会是空字符串 ""
        default=None,
        help="Write all outputs to this file instead of the terminal (if no argument is given, defaults to <testcases_folder>+result)"
    )

    args = parser.parse_args()

    if args.testcases_folder != None:
        testcases_folder = f"../testcases/{args.testcases_folder}"
    elif args.myfolder_path != None:
        testcases_folder = f"../test/{args.myfolder_path}"
    else:
        print("Error: You must specify either -t <testcases_folder> or -m <myfolder_path>.")
        sys.exit(1)
    max_test_num = args.max_test_num
    outputfile = args.outputfile
    if outputfile == "":
        outputfile = f"{args.testcases_folder}-result"

    # 统一输出流与颜色开关
    out_stream = sys.stdout
    if outputfile:
        out_stream = open(outputfile, "w", encoding="utf-8")

    use_color = (out_stream is sys.stdout and hasattr(out_stream, "isatty") and out_stream.isatty())
    if not use_color:
        # 写文件或非 TTY：去掉 ANSI 颜色以避免日志包含控制符
        global GREEN, RED, RESET
        GREEN = RED = RESET = ""

    def log(*a, **kw):  # 统一打印
        print(*a, file=out_stream, **kw)
        try:
            out_stream.flush()
        except Exception:
            pass

    # 基本检查
    if not os.path.exists(testcases_folder):
        log(f"Error: Folder {testcases_folder} does not exist.")
        if outputfile and out_stream is not sys.stdout:
            out_stream.close()
        sys.exit(1)
    if not os.path.isdir(testcases_folder):
        log(f"Error: {testcases_folder} is not a folder.")
        if outputfile and out_stream is not sys.stdout:
            out_stream.close()
        sys.exit(1)
    if not os.path.exists(checker_path):
        log(f"Error: Checker {checker_path} does not exist.")
        if outputfile and out_stream is not sys.stdout:
            out_stream.close()
        sys.exit(1)
    if not os.path.isfile(checker_path):
        log(f"Error: {checker_path} is not a file.")
        if outputfile and out_stream is not sys.stdout:
            out_stream.close()
        sys.exit(1)
    if not os.access(checker_path, os.X_OK):
        log(f"Error: Checker {checker_path} is not executable.")
        if outputfile and out_stream is not sys.stdout:
            out_stream.close()
        sys.exit(1)

    total_tests = 0
    passed_tests = 0
    failed_tests = 0

    # 确定性顺序
    for testcase in sorted(os.listdir(testcases_folder)):
        # 如果指定了前缀且不匹配则跳过
        if args.pre is not None and not testcase.startswith(args.pre):
            continue

        testcase_path = os.path.join(testcases_folder, testcase)
        if not os.path.isdir(testcase_path):
            continue

        # 找 .rx 和 .json（只允许唯一各 1 个）
        rx_candidates = [n for n in os.listdir(testcase_path) if n.endswith(".rx")]
        json_candidates = [n for n in os.listdir(testcase_path) if n.endswith(".json")]

        log(f"testing {testcase}...")

        if len(rx_candidates) != 1 or len(json_candidates) != 1:
            log(f"Warning: {testcase} should contain exactly one .rx and one .json "
                f"(got {len(rx_candidates)} .rx, {len(json_candidates)} .json). Skipping.")
            continue

        rs_file = os.path.join(testcase_path, rx_candidates[0])
        json_file = os.path.join(testcase_path, json_candidates[0])

        total_tests += 1

        try:
            # 读期望值
            expected_content = load_expected_exitcode(json_file)

            # 运行 checker：stdin= .rx 内容，捕获 stdout/stderr
            with open(rs_file, "rb") as fin:
                result = subprocess.run(
                    [checker_path],
                    stdin=fin,
                    capture_output=True,  # 捕获 stdout/stderr（bytes）
                    text=True             # 解码为 str（默认 utf-8 / locale）
                )

            # RE 检测与输出（包含 stderr）
            if result.returncode != 0:
                failed_tests += 1
                log(f"{RED}{CROSS}{RESET} {testcase} (RE) - checker exited with code {result.returncode}")
                if result.stderr:
                    log("=== stderr ===")
                    log(result.stderr.strip())
                if max_test_num != -1 and total_tests >= max_test_num:
                    break
                continue

            # 从 stdout 解析整数
            output_content = parse_int_from_text(result.stdout)

            if output_content is None:
                failed_tests += 1
                log(f"{RED}{CROSS}{RESET} {testcase} failed (stdout not an int).")
                log(f"Expect {expected_content}, Read <parse-failed>")
                if result.stderr:
                    log("=== stderr ===")
                    log(result.stderr.strip())
            else:
                if output_content == expected_content:
                    passed_tests += 1
                    log(f"{GREEN}{CHECK}{RESET} {testcase} passed")
                else:
                    failed_tests += 1
                    log(f"{RED}{CROSS}{RESET} {testcase} failed")
                    log(f"Expect {expected_content}, Read {output_content}")
                    # 当输出为 -1 时打印错误
                    if output_content == -1:
                        if result.stderr:
                            log("=== stderr ===")
                            log(result.stderr.strip())
                        else:
                            log("=== stderr is empty ===")

        except Exception as e:
            failed_tests += 1
            log(f"{RED}{CROSS}{RESET} {testcase} raised an exception: {e}")

        if max_test_num != -1 and total_tests >= max_test_num:
            break

    log(f"Total test cases: {total_tests}, Passed: {passed_tests}, Failed: {failed_tests}")

    # NEW: 如果写入文件，结束时关闭
    if outputfile and out_stream is not sys.stdout:
        out_stream.close()

if __name__ == "__main__":
    main()
